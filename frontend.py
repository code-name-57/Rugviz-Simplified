from fastapi import FastAPI
from nicegui import app, ui, events
from backend import create_hero, read_hero, update_hero, delete_hero, list_heroes, create_background, list_backgrounds, update_background, delete_background
from models import Hero, RVBackground
import asyncio
import os
import pathlib
import shlex
import shutil
import subprocess

class HeroApp:
    def __init__(self, fastapi_app: FastAPI) -> None:
        self.fastapi_app = fastapi_app

        # state properties
        self.editing_id = None
        self.hero_list = None
        self.name_input = None
        self.power_input = None

        self.setup_ui()

        ui.run_with(
            self.fastapi_app,
            mount_path='/gui',  # Optional: if omitted then @ui.page paths are at the root
            storage_secret='pick your private secret here',
        )

    

    def setup_ui(self):
        @ui.page('/')
        def show():
            def refresh_hero_list(self):
                self.hero_list.clear()
                heroes = list_heroes()  # Get updated heroes from the database
                print(heroes)
                for hero in heroes:
                    with self.hero_list:
                        with ui.row().classes('items-center'):
                            ui.label(f"{hero.id}: {hero.name} - {hero.secret_name}")
                            ui.button('Edit', on_click=lambda hero_id=hero.id: self.edit_hero(hero_id)).classes('ml-2')
                            ui.button('Delete', on_click=lambda hero_id=hero.id: self.delete_hero(hero_id)).classes('ml-2')

            def submit_hero(self):
                if self.editing_id is None:
                    # Create new hero using backend function
                    new_hero_dict = {
                        'id': None,  # id is usually auto-generated by the SQL database
                        'name': self.name_input.value,
                        'secret_name': self.power_input.value,
                    }
                    new_hero = Hero.model_validate(new_hero_dict)
                    create_hero(new_hero)
                else:
                    # Update existing hero using backend function
                    updated_hero_dict = {
                        'id': self.editing_id,
                        'name': self.name_input.value,
                        'secret_name': self.power_input.value,
                    }
                    updated_hero = Hero.model_validate(updated_hero_dict)
                    update_hero(updated_hero)
                    self.editing_id = None

                self.name_input.value = ''
                self.power_input.value = ''
                self.refresh_hero_list()

            def edit_hero(self, hid: int):
                # Optional: call read_hero if you prefer fetching latest details from the DB
                hero = read_hero(hid)
                if hero:
                    self.editing_id = hid
                    self.name_input.value = hero.name
                    self.power_input.value = hero.secret_name

            def delete_hero(self, hid: int):
                delete_hero(hid)
                if self.editing_id == hid:
                    self.editing_id = None
                    self.name_input.value = ''
                    self.power_input.value = ''
                self.refresh_hero_list()



            ui.label('Hello, FastAPI!')

            # persist dark mode across tabs / restarts
            ui.dark_mode().bind_value(app.storage.user, 'dark_mode')
            ui.checkbox('dark mode').bind_value(app.storage.user, 'dark_mode')

            with ui.card().classes('p-4'):
                ui.label('Hero Form').classes('text-h5')
                self.name_input = ui.input(label='Name')
                self.power_input = ui.input(label='Power')
                ui.button('Submit', on_click=self.submit_hero)

            ui.separator()

            ui.label('Heroes List').classes('text-h5 mb-2')
            self.hero_list = ui.column()

            self.refresh_hero_list()

        @ui.page('/backgrounds/')
        def show_backgound_list():
            # build UI elements first
            ui.label("Background Images List").classes('text-h5')
            background_list = ui.column()
            calibration_dialog = ui.dialog()
            with calibration_dialog as dialog, ui.card():
                ui.label('Hello world!')
                ui.button('Close', on_click=dialog.close)
            ui.button('Open a dialog', on_click=calibration_dialog.open)


            def refresh_background_list():
                background_list.clear()
                for bg in list_backgrounds():
                    with background_list:
                        with ui.row().classes('items-center'):
                            ui.image(source=bg.image_path)
                            ui.button("Edit", on_click=lambda bg_id=bg.id: open_edit_dialog(bg_id)).classes("ml-2")
                            ui.button("Delete", on_click=lambda bg_id=bg.id: delete_bg(bg_id)).classes("ml-2")
            
            def delete_bg(bg_id: int):
                delete_background(bg_id)
                refresh_background_list()


            def open_edit_dialog(bg_id: int):
                # Retrieve current background details
                bg = None
                for item in list_backgrounds():
                    if item.id == bg_id:
                        bg = item
                        break
                if bg is None:
                    ui.notify("Background not found", color="warning")
                    return

                d = ui.dialog()
                annotation = {}  # Will hold annotation coordinates as {'start': (x, y), 'end': (x, y)}
                with d, ui.card().classes("p-4"):
                    ui.label("Annotate the image with a rectangle")
                    # Display current image
                    annotated_image = ui.interactive_image(bg.image_path, on_mouse=lambda e: on_mouse(e, annotation), events=["mousedown", "mouseup","mousemove"])
                    
                    def on_mouse(e: events.MouseEventArguments, coords: dict):
                        # Initialize points list if not already set
                        if "points" not in coords:
                            coords["points"] = []
                        # Define a threshold to detect if a click is close enough to an existing point (in image coordinates)
                        threshold = 10

                        if e.type == "mousedown":
                            # Check if the click is near an existing point for dragging
                            for i, (px, py) in enumerate(coords["points"]):
                                if abs(e.image_x - px) < threshold and abs(e.image_y - py) < threshold:
                                    coords["drag_index"] = i
                                    break
                            else:
                                # If no nearby point found and we have less than 4 points, add a new one
                                if len(coords["points"]) < 4:
                                    coords["points"].append((e.image_x, e.image_y))
                                    ui.notify(f"Point {len(coords['points'])} added", color="primary")
                                else:
                                    ui.notify("Already 4 points set.", color="warning")
                        
                        elif e.type == "mousemove":
                            # If dragging an existing point, update its coordinates continuously.
                            if "drag_index" in coords:
                                idx = coords["drag_index"]
                                coords["points"][idx] = (e.image_x, e.image_y)
                        
                        elif e.type == "mouseup":
                            if "drag_index" in coords:
                                ui.notify(f"Point {coords['drag_index']+1} moved", color="primary")
                                del coords["drag_index"]

                        update_svg(coords)

                    def update_svg(coords: dict):
                        points = coords.get("points", [])
                        svg_elements = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">'
                        
                        # Draw circles for each point.
                        for (x, y) in points:
                            svg_elements += f'<circle cx="{x}" cy="{y}" r="5" fill="red" />'
                        
                        # Draw lines connecting the points in order.
                        if len(points) > 1:
                            for i in range(len(points) - 1):
                                x1, y1 = points[i]
                                x2, y2 = points[i+1]
                                svg_elements += f'<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" stroke="blue" stroke-width="2" />'
                            
                            # If 4 points, close the polygon.
                            if len(points) == 4:
                                x1, y1 = points[-1]
                                x2, y2 = points[0]
                                svg_elements += f'<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" stroke="blue" stroke-width="2" />'
                                
                                # Create a mask using the drawn polygon.
                                polygon_points = " ".join(f"{x},{y}" for x, y in points)
                                svg_elements += f'''
                                    <defs>
                                      <mask id="mask">
                                        <rect x="0" y="0" width="100%" height="100%" fill="white" />
                                        <polygon points="{polygon_points}" fill="black" />
                                      </mask>
                                    </defs>
                                    <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0.5)" mask="url(#mask)" />
                                '''
                        svg_elements += '</svg>'
                        annotated_image.content = svg_elements
                    
                    ui.button("Save Annotation", on_click=lambda: save_edited(bg_id, annotation, d)).classes("mt-2")
                d.open()
            
            def save_edited(bg_id: int, coords: dict, dialog):
                if "start" in coords and "end" in coords:
                    # Assuming update_background accepts a dict with new annotation info
                    # You can store the rectangle points as needed (here simply as a string)
                    rect_annotation = f"{coords['start']} to {coords['end']}"
                    update_background({"id": bg_id, "annotation": rect_annotation})
                    ui.notify("Background updated", color="positive")
                    dialog.close()
                    refresh_background_list()
                else:
                    ui.notify("Please annotate by selecting two points.", color="warning")
            
            async def handle_upload(args: events.UploadEventArguments):
                if 'image' in args.type:
                    # Handle image file uploads
                    os.makedirs('data', exist_ok=True)
                    os.chdir('data')
                    with open(args.name, 'wb') as f:
                        f.write(args.content.read())
                    # Update the interactive image to the newly uploaded image.
                    background_obj = RVBackground.model_validate({'image_path': f'/data/{args.name}'})
                    create_background(background_obj)

                    ui.notify("Image uploaded successfully.", color="positive")
                    refresh_background_list()
                    os.chdir('..')
                    upload.run_method('reset')

            os.makedirs('data', exist_ok=True)
            app.add_static_files('/data', 'data')

            with ui.column().classes('w-full items-center'):
                ui.label('Extract images from video').classes('text-3xl m-3')
                upload = ui.upload(label='pick a video file', auto_upload=True, on_upload=handle_upload)
                results = ui.row().classes('w-full justify-center mt-6')
            refresh_background_list()

        @ui.page('/backgrounds/{id}/')
        def show_edit_background(id: int):
            points = []
            points_list_ui = ui.column()

            os.makedirs('data', exist_ok=True)
            app.add_static_files('/data', 'data')

            def update_svg():
                # Redraw the SVG overlay
                background_image.content = ""
                svg_elements = ""

                # Draw circles for each selected point
                for (x, y) in points:
                    svg_elements += f'<circle cx="{x}" cy="{y}" r="5" fill="red" />'

                # Draw lines connecting the points
                if len(points) > 1:
                    for i in range(len(points) - 1):
                        x1, y1 = points[i]
                        x2, y2 = points[i+1]
                        svg_elements += f'<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" stroke="green" stroke-width="2" />'
                    # Automatically close the polygon once 4 points are set
                    if len(points) == 4:
                        x1, y1 = points[-1]
                        x2, y2 = points[0]
                        svg_elements += f'<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" stroke="green" stroke-width="2" />'

                # Add a translucent mask over the image showing the drawn polygon
                if len(points) == 4:
                    polygon_points = " ".join([f"{x},{y}" for x, y in points])
                    overlay_rect = f'''
                        <defs>
                          <mask id="cutout">
                            <rect x="0" y="0" width="100%" height="100%" fill="white"/>
                            <polygon points="{polygon_points}" fill="black"/>
                          </mask>
                        </defs>
                        <rect x="0" y="0" width="100%" height="100%" fill="rgba(0, 0, 0, 0.5)" mask="url(#cutout)"/>
                        '''
                else:
                    overlay_rect = ''
                svg_elements = overlay_rect + svg_elements
                background_image.content = svg_elements

            def update_points_ui():
                points_list_ui.clear()
                for idx, (x, y) in enumerate(points):
                    with points_list_ui:
                        with ui.row():
                            ui.label(f"Point {idx+1}: ({x:.1f}, {y:.1f})")
                            ui.button("Remove", on_click=lambda idx=idx: remove_point(idx)).classes('ml-2')

            def remove_point(index: int):
                if index < len(points):
                    points.pop(index)
                    update_svg()
                    update_points_ui()

            def camera_mouse_handler(e: events.MouseEventArguments):
                try:
                    # Only process mousedown events
                    if e.type != 'mousedown':
                        return

                    # Left click (button 0) adds a point; right click (button 2) removes the last point.
                    if e.button == 0:
                        if len(points) >= 4:
                            ui.notify("Already 4 points set.", color="warning")
                        else:
                            points.append((e.image_x, e.image_y))
                    elif e.button == 2:
                        if points:
                            points.pop()
                        else:
                            ui.notify("No points to remove.", color="warning")
                    else:
                        return

                    update_svg()
                    update_points_ui()
                except Exception as err:
                    ui.notify(f"Error: {str(err)}", color="negative")

            # persist dark mode across tabs / restarts
            ui.dark_mode().bind_value(app.storage.user, 'dark_mode')
            ui.checkbox('dark mode').bind_value(app.storage.user, 'dark_mode')
            background_image = ui.interactive_image('./top_view.png', on_mouse=camera_mouse_handler, events=['mousedown', 'mouseup'], cross=True)


# Usage/initialization example:
def init(fastapi_app: FastAPI) -> None:
    HeroApp(fastapi_app)